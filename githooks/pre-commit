#!/usr/bin/python
import datetime
import subprocess
import sys
from contextlib import contextmanager


@contextmanager
def stash_unstaged():
    try:
        # See https://stackoverflow.com/a/20480591/22222542
        print("Stashing unstaged code")
        # Get the name/hash of the most recent stash, if it exists
        old_stash = subprocess.run(
            ["git", "rev-parse", "-q", "--verify", "refs/stash"], stdout=subprocess.PIPE
        ).stdout
        # Stash the index and work dir, keeping only the to-be-committed
        # changes in the work dir
        stash_name = f"pre-commit-{datetime.datetime.now()}"
        subprocess.call(["git", "stash", "--quiet", "--keep-index", "--include-untracked"])
        # Get the name/hash of the new most recent stash
        new_stash = subprocess.run(
            ["git", "rev-parse", "-q", "--verify", "refs/stash"], stdout=subprocess.PIPE
        ).stdout
        # If there were no changes then nothing was stashed, and we can exit early
        # (Presumably, the code which has been committed is already formatted and tested)
        if old_stash == new_stash:
            print("No changes detected, so pre-commit is passing")
        #    exit(0)
        # Give control to the caller, so it can do its stuff
        yield
    finally:
        print("Popping stash")
        # Restore any stashed changes
        subprocess.call(["git", "reset", "--hard", "--quiet"])
        subprocess.call(["git", "stash", "pop", "--index", "--quiet"])


def autofix_msg(command: list[str]):
    # Suggest a command to fix the errors
    print("\033[96mTo autofix errors, try running the following command:")
    print(" ".join(command))
    print("\033[0m")


def exit_on_error(code: int):
    if code != 0:
        sys.exit(code)


def get_files() -> list[str] | None:
    # Get a list of files to be committed
    files = subprocess.run(
        ["git", "diff-index", "--cached", "--name-only", "HEAD"], stdout=subprocess.PIPE
    ).stdout
    files = files.decode("utf-8").split("\n")
    files = filter((lambda f: f.endswith(".cs")), files)
    files = list(files)
    print(files)
    if len(files) == 0:
        return None
    return files


def lint_style(files: list[str]) -> int:
    # Check the files using dotnet format
    # (See https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-format)
    command = [
        "dotnet",
        "format",
        "style",
        "backend24.sln",
        "--verify-no-changes",
        "--include",
    ] + files
    exit_code = subprocess.call(command)

    if exit_code != 0:
        command.remove("--verify-no-changes")
        autofix_msg(command)

    return exit_code


def lint_analyzers(files: list[str]) -> int:
    # Check the files using dotnet format
    # (See https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-format)
    command = [
        "dotnet",
        "format",
        "analyzers",
        "backend24.sln",
        "--verify-no-changes",
        "--include",
    ] + files
    exit_code = subprocess.call(command)

    if exit_code != 0:
        command.remove("--verify-no-changes")
        autofix_msg(command)

    return exit_code


def format(files: list[str]) -> int:
    # Check the files using dotnet format
    # (See https://learn.microsoft.com/en-us/dotnet/core/tools/dotnet-format)
    command = [
        "dotnet",
        "csharpier",
        "--check",
    ] + files
    exit_code = subprocess.call(command)

    if exit_code != 0:
        command.remove("--check")
        autofix_msg(command)

    return exit_code


def main():
    exit_code = 0
    with stash_unstaged():
        files = get_files()
        if files is None:
            print("No .cs files changed, skipping checks")
            sys.exit(0)
        for method in [format, lint_style, lint_analyzers]:
            exit_on_error(method(files))


if __name__ == "__main__":
    main()
